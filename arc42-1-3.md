# 

**Architekturüberblick 0 A.D.**

0 A.D. ist ein freies, open-source Echtzeit-Strategiespiel, das von Wildfire Games entwickelt wird.
Es simuliert historische Zivilisationen und kombiniert den Aufbau von Städten, das Sammeln von Ressourcen und taktische Schlachten in einer antiken Welt.

Dieser Architekturüberblick beschreibt die grundlegenden Konzepte und Entwurfsentscheidungen des Projekts. Er zeigt die Struktur der Software, das Zusammenspiel der zentralen Komponenten und die Prinzipien, auf denen die Architektur von 0 A.D. basiert.Die Gliederung folgt der arc42-Vorlage.

Zielgruppe dieses Überblicks sind Softwarearchitektinnen und -architekten, Studierende sowie Entwicklerinnen und Entwickler, die die modulare, erweiterbare Architektur von 0 A.D. nachzuvollziehen möchten.


# 1 Einführung und Ziele 

Dieser Abschnitt führt in die Aufgabenstellung ein und erklärt, welche Ziele 0 A.D. verfolgt.

## 1.1 Aufgabenstellung 

- 0 A.D. verbindet historische Geschichte mit strategischem Gameplay
- Spielende übernehmen die Kontrolle über historische Zivilisationen, errichten Städte, verwalten Ressourcen und führen strategische Schlachten.  
- Ziel des Projekts ist ein frei zugängliches Strategiespiel, das gemeinschaftlich entwickelt wird und historische Inhalte mit spielerischem Anspruch verbindet. 
- Das Spiel richtet sich an Gelegenheitsspielende ebenso wie an Personen, die sich für Geschichte, Strategie und offene Entwicklungsprojekte interessieren.  
- 0 A.D. wird von einer aktiven Community gepflegt und kontinuierlich weiterentwickelt.

## 1.2 Qualitätsziele 

Die folgende Tabelle fasst die wichtigsten Qualitätsziele von 0 A.D. zusammen. Die Reihenfolge dient dabei als grobe Orientierung für ihre Bedeutung in der Architektur.

| **Qualitätsziel** | **Motivation und Erläuterung** |
|----------------|-----------------------------|
| Erweiterbarkeit / Modding-Freundlichkeit | 0 A.D. soll leicht um neue Zivilisationen, Karten und Spielmechaniken erweitert werden. Eine offene Modding-Struktur ist Kern der Projektphilosophie und fördert langfristige Community-Beteiligung. |
|  Leistungseffizienz | Das Spiel muss auch bei großen Karten und vielen Einheiten flüssig laufen. Hohe Effizienz prägt Engine-Design und Simulation. |
|  Wartbarkeit  | Der Quellcode soll für freiwillige Entwickler:innen klar strukturiert, dokumentiert und leicht anpassbar bleiben. |
|  Portabilität | 0 A.D. soll auf allen wichtigen Betriebssystemen (Windows, Linux, macOS) lauffähig sein, um eine breite Nutzerbasis zu erreichen. |
|  Multiplayer-Zuverlässigkeit | Sowohl Einzel- als auch Mehrspieler-Modus sollen zuverlässig funktionieren; deterministische Simulation verhindert Desynchronisation. |

## 1.3 Stakeholder

Dieser Abschnitt beschreibt die wichtigsten Interessengruppen von 0 A.D.  
Jede Gruppe hat ein spezifisches Interesse und einen unterschiedlichen Bezug zur Softwarearchitektur.

| **Wer?** | **Interesse und Bezug** |
|------|----------------------|
| Spielerinnen und Spieler | Nutzen das Spiel zur Unterhaltung und erwarten eine stabile, performante und zugängliche Spielerfahrung. Ihre Rückmeldungen beeinflussen Prioritäten für Performance und Benutzerfreundlichkeit. |
| Entwicklerinnen und Entwickler *(Kernentwickler, Modder, Künstler, Community-Beitragende)* | - Arbeiten direkt am C++-Kern und an JavaScript-basierten Inhalten.  <br> - Benötigen eine modulare, dokumentierte und erweiterbare Architektur.  <br> - Schätzen klare Schnittstellen und eine offene Entwicklungsumgebung für Zusammenarbeit. |
| Maintainer | - Verantwortlich für Qualitätssicherung, Fehlerbehebung und Veröffentlichung neuer Versionen.  <br> - Achten auf Stabilität, Reproduzierbarkeit und einfache Integration von Community-Beiträgen. |
| Akademische & Bildungseinrichtungen | Verwenden 0 A.D. als Open-Source-Fallstudie für Themen wie Simulation, KI und Softwarearchitektur. Sie erwarten nachvollziehbare Designentscheidungen und eine transparente Projektstruktur. |

# 2 Randbedingungen 

## 2.1 Technische Randbedingungen

| **Randbedingung** | **Erläuterungen, Hintergrund** |
|----------------|----------------------------------|
| Implementierung in C++ und JavaScript | Die Engine (*Pyrogenesis*) ist in C++ implementiert, während Spiel-Logik und Simulation in JavaScript realisiert sind. |
| Moderate Hardwareanforderungen | 0 A.D. soll auch auf durchschnittlicher Hardware flüssig spielbar sein. Dies beeinflusst Rendering, Speicherverwaltung und Optimierungsstrategien. |
| Entwicklungswerkzeuge | Für die Entwicklung werden ausschließlich freie und plattformübergreifende Werkzeuge wie Git, CMake, GCC/Clang und Phabricator verwendet. Dadurch können alle Beitragenden unabhängig von Betriebssystem und kommerzieller Software arbeiten. |
| Freie Drittanbieter-Bibliotheken | Alle externen Bibliotheken müssen GPL-kompatibel sein. Dadurch sind nur Open-Source-Alternativen (z. B. OpenAL, ENet) zulässig. |

---

## 2.2 Organisatorische Randbedingungen

| **Randbedingung** | **Erläuterung, Hintergrund** |
|--------------------|-------------------------------|
| Team | Das Projekt wird von der internationalen Open-Source-Community Wildfire Games getragen und besteht aus Freiwilligen und wird heute von freiwilligen Entwickler:innen, Künstler:innen und Designer:innen gepflegt. |
| Vorgehensmodell | Die Entwicklung erfolgt iterativ und community-getrieben. Beiträge werden über öffentliche Code-Reviews diskutiert und integriert; Entscheidungen über Architektur und Features werden gemeinschaftlich getroffen. |
| Entwicklungswerkzeuge | Für die Entwicklung werden ausschließlich freie Werkzeuge verwendet. Quellcode wird mit Git versioniert, Code-Reviews erfolgen über Phabricator und der Build-Prozess wird mit CMake, GCC/Clang und Python-Skripten automatisiert. |
| Konfigurations- und Versionsverwaltung | Der Quellcode ist auf GitHub verfügbar. Versionskontrolle und Review-Prozesse erfolgen über Git und Phabricator, wodurch Änderungen nachvollziehbar und transparent bleiben. |
| Test- und Build-Prozesse | Automatisierte Builds und Community-Tests sichern Stabilität und Nachvollziehbarkeit. Fehlerberichte und Testergebnisse werden in Phabricator dokumentiert. |
| Veröffentlichung als Open Source | Der gesamte Quellcode und die Spieldaten werden unter der GNU General Public License Version 2 (GPLv2) veröffentlicht. Alle Assets stehen unter freien Lizenzen (z. B. CC-BY-SA). Die Quellen sind öffentlich über [https://github.com/0ad/0ad](https://github.com/0ad/0ad) zugänglich. |

---

## 2.3 Konventionen

| **Randbedingung** | **Erläuterungen, Hintergrund** |
|-------------|----------------------------------|
| Architekturdokumentation | Das Projekt nutzt Wiki- und Textdokumente (Markdown-ähnliche Struktur), um technische und architektonische Entscheidungen nachvollziehbar zu dokumentieren. |
| Kodierrichtlinien für C++ | Der C++-Code folgt den internen Style-Guidelines von Wildfire Games (angelehnt an den Google C++ Style Guide) und wird durch Code-Reviews sowie clang-format überprüft |
| Daten- und Asset-Formate | 0 A.D. verwendet ausschließlich offene Formate wie XML, JSON, PNG und OGG, die Modding und langfristige Kompatibilität ermöglichen. |
| Sprachunterstützung | 0 A.D.unterstützt mehreren Sprachen und bietet Lokalisierungsunterstützung über `.po`-Dateien im UTF-8-Format, um den Einsatz in verschiedenen Sprachräumen zu ermöglichen. Die Übersetzungen werden gemeinschaftlich über die Plattform Transifex gepflegt. |


# 3 Kontextabgrenzung 

## 3.1 Fachlicher Kontext 
 
 In diesem Abschnitt werden die Kommunikationsbeziehungen von **0 A.D.** zu externen Akteuren und domänenspezifischen Datenquellen beschrieben. Die folgende Abbildung stellt diese Beziehungen dar. Sie zeigt sowohl menschliche Benutzerrollen als auch Daten- und Inhaltsquellen, mit denen das Spiel Informationen austauscht.

 ![Fachlicher Kontext von 0 A.D.](images/Fachlicher-Kontext.drawio.png)
 
 Abbildung 3.1: Fachlicher Kontext von 0 A.D.
---

**Spieler:innen (Benutzer)**
**Spieler:innen interagieren direkt mit 0 A.D. indem sie Spiele starten, Karten auswählen, Zivilisationen wählen und Partien im Einzel- oder Mehrspielermodus durchführen.  
Eingabedaten sind hier Benutzereinstellungen und Steuerungsaktionen (z. B. Mausklicks, Tastatureingaben).  
Ausgabedaten sind Spielereignisse, visuelle Darstellungen und Spielstände.

**Modder / Community (Benutzer)**
Modder:innen erstellen neue Spielinhalte, wie Zivilisationen, Einheiten oder Karten, über die Modding-Interface von 0 A.D..  
Eingabedaten sind neue oder geänderte Dateien im Mod-Ordner (z. B. XML- und JSON-Dateien).  
Ausgabedaten sind die von der Engine geladenen Inhalte, die das Spiel erweitern oder verändern.

***Übersetzer:innen (Benutzer)**
Übersetzer:innen pflegen die Sprachdateien des Spiels über die Plattform Transifex.  
Eingabedaten sind übersetzte Texte im `.po`-Format, während Ausgabedaten aktualisierte Sprachdateien im Spiel sind, die mehrsprachige Benutzeroberflächen ermöglichen.

**Maintainer / Entwickler:innen (Benutzer)**
Maintainer und Entwickler:innen koordinieren Beiträge aus der Community, führen Code-Reviews durch und veröffentlichen neue Versionen des Spiels.  
Sie interagieren über Versionskontroll- und Review-Systeme (Git, Phabricator), die aber im fachlichen Kontext nur indirekt relevant sind.

**Karten / Szenarien (Fremdsystem)**
Karten definieren die Spielwelt, Ressourcenverteilung und Startpositionen. Sie werden vom Spiel beim Start einer Partie geladen.  
Eingabedaten sind XML/JSON-basierte Szenariodateien, Ausgabedaten sind visuelle Karten- und Umgebungselemente im Spiel.

**Mods / Erweiterungen (Fremdsystem)**
Mods sind externe Inhaltspakete, die von der Community erstellt werden. Sie erweitern oder ersetzen Spielmechaniken, Einheiten oder Ressourcen.  
Eingabedaten sind modifizierte Assets oder Skripte, Ausgabedaten sind die in das Spiel integrierten Inhalte.

**Spielstände / Replays (Fremdsystem)**
0 A.D. speichert laufende Partien als Spielstände und aufgezeichnete Replays.  
Eingabedaten sind zuvor gespeicherte Dateien, Ausgabedaten sind die wiederhergestellten oder exportierten Spieldaten.

**Transifex Plattform (Fremdsystem)**
Die Plattform Transifex dient zur Verwaltung und Pflege von Übersetzungen.  
0 A.D. importiert und exportiert `.po`-Dateien über diese Schnittstelle, um Sprachaktualisierungen in die Community zurückzuführen.


## 3.2 Technischer Kontext 

Der technische Kontext beschreibt die externen Systeme, Laufzeitumgebungen und Bibliotheken, mit denen **0 A.D.** interagiert.  
Die folgende Abbildung zeigt die wichtigsten technischen Abhängigkeiten des Spiels.

![Technischer Kontext von 0 A.D.](images/Technischer-Kontext.drawio.png)
Abbildung 3.2: Technischer Kontext von 0 A.D.
---

**Betriebssystem (Windows / Linux / macOS)**
0 A.D. ist plattformübergreifend und nutzt die Betriebssysteme für grundlegende Dienste wie Dateizugriff, Eingabeverarbeitung (Maus, Tastatur) und Netzwerkkommunikation.  
Die Engine abstrahiert diese Funktionen über plattformunabhängige Bibliotheken (z. B. SDL).

**OpenGL (Grafik-API)**
Für die grafische Darstellung verwendet 0 A.D. die offene Programmierschnittstelle OpenGL.  
Diese ermöglicht hardwarebeschleunigtes Rendering von 3D-Objekten, Texturen und Effekten.

**OpenAL (Audio-API)**
Für die Audiowiedergabe nutzt 0 A.D. OpenAL, eine plattformübergreifende Audio-Bibliothek.  
Sie ermöglicht die räumliche Positionierung von Soundeffekten und Musik im Spiel.

**SpiderMonkey (JavaScript-Engine)**
Die JavaScript-Engine SpiderMonkey (entwickelt von Mozilla) wird zur Ausführung von Spielskripten verwendet.  
Sie ermöglicht die Steuerung von Simulation, Künstlicher Intelligenz (KI) und spielinterner Logik.

**ENet (Netzwerkbibliothek)**
Für den Mehrspielermodus verwendet 0 A.D. die leichtgewichtige Netzwerkbibliothek ENet.  
Sie sorgt für zuverlässige, latenzarme Kommunikation zwischen Clients und Servern über UDP.

**Dateisystem (Mods, Saves, Config)**
0 A.D greift über das lokale Dateisystem auf Spielinhalte, Mods, Konfigurationen und gespeicherte Spielstände zu.  
Hierüber erfolgt auch die Einbindung von benutzerdefinierten Erweiterungen und Ressourcen.

**Transifex (Übersetzungsplattform)**
Zur Verwaltung der Übersetzungen wird der externe Dienst Transifex eingesetzt.  
Über diese Schnittstelle werden `.po`-Dateien für Lokalisierungen importiert und exportiert.


# Lösungsstrategie {#section-solution-strategy}

:::::::::::: sidebar
::: title
:::

:::: formalpara
::: title
Inhalt
:::

Kurzer Überblick über die grundlegenden Entscheidungen und
Lösungsansätze, die Entwurf und Implementierung des Systems prägen.
Hierzu gehören:
::::

- Technologieentscheidungen

- Entscheidungen über die Top-Level-Zerlegung des Systems,
  beispielsweise die Verwendung gesamthaft prägender Entwurfs- oder
  Architekturmuster,

- Entscheidungen zur Erreichung der wichtigsten Qualitätsanforderungen
  sowie

- relevante organisatorische Entscheidungen, beispielsweise für
  bestimmte Entwicklungsprozesse oder Delegation bestimmter Aufgaben an
  andere Stakeholder.

:::: formalpara
::: title
Motivation
:::

Diese wichtigen Entscheidungen bilden wesentliche „Eckpfeiler" der
Architektur. Von ihnen hängen viele weitere Entscheidungen oder
Implementierungsregeln ab.
::::

:::: formalpara
::: title
Form
:::

Fassen Sie die zentralen Entwurfsentscheidungen **kurz** zusammen.
Motivieren Sie, ausgehend von Aufgabenstellung, Qualitätszielen und
Randbedingungen, was Sie entschieden haben und warum Sie so entschieden
haben. Vermeiden Sie redundante Beschreibungen und verweisen Sie eher
auf weitere Ausführungen in Folgeabschnitten.
::::

:::: formalpara
::: title
Weiterführende Informationen
:::

Siehe [Lösungsstrategie](https://docs.arc42.org/section-4/) in der
online-Dokumentation (auf Englisch!).
::::
::::::::::::

# Bausteinsicht {#section-building-block-view}

:::::::::::: sidebar
::: title
:::

:::: formalpara
::: title
Inhalt
:::

Die Bausteinsicht zeigt die statische Zerlegung des Systems in Bausteine
(Module, Komponenten, Subsysteme, Klassen, Schnittstellen, Pakete,
Bibliotheken, Frameworks, Schichten, Partitionen, Tiers, Funktionen,
Makros, Operationen, Datenstrukturen, ...​) sowie deren Abhängigkeiten
(Beziehungen, Assoziationen, ...​)
::::

Diese Sicht sollte in jeder Architekturdokumentation vorhanden sein. In
der Analogie zum Hausbau bildet die Bausteinsicht den *Grundrissplan*.

:::: formalpara
::: title
Motivation
:::

Behalten Sie den Überblick über den Quellcode, indem Sie die statische
Struktur des Systems durch Abstraktion verständlich machen.
::::

Damit ermöglichen Sie Kommunikation auf abstrakterer Ebene, ohne zu
viele Implementierungsdetails offenlegen zu müssen.

:::: formalpara
::: title
Form
:::

Die Bausteinsicht ist eine hierarchische Sammlung von Blackboxen und
Whiteboxen (siehe Abbildung unten) und deren Beschreibungen.
::::

![Hierarchie in der Bausteinsicht](images/05_building_blocks-DE.png)

**Ebene 1** ist die Whitebox-Beschreibung des Gesamtsystems, zusammen
mit Blackbox-Beschreibungen der darin enthaltenen Bausteine.

**Ebene 2** zoomt in einige Bausteine der Ebene 1 hinein. Sie enthält
somit die Whitebox-Beschreibungen ausgewählter Bausteine der Ebene 1,
jeweils zusammen mit Blackbox-Beschreibungen darin enthaltener
Bausteine.

**Ebene 3** zoomt in einige Bausteine der Ebene 2 hinein, usw.

:::: formalpara
::: title
Weiterführende Informationen
:::

Siehe [Bausteinsicht](https://docs.arc42.org/section-5/) in der
online-Dokumentation (auf Englisch!).
::::
::::::::::::

## Whitebox Gesamtsystem {#_whitebox_gesamtsystem}

:::: sidebar
::: title
:::

An dieser Stelle beschreiben Sie die Zerlegung des Gesamtsystems anhand
des nachfolgenden Whitebox-Templates. Dieses enthält:

- Ein Übersichtsdiagramm

- die Begründung dieser Zerlegung

- Blackbox-Beschreibungen der hier enthaltenen Bausteine. Dafür haben
  Sie verschiedene Optionen:

  - in *einer* Tabelle, gibt einen kurzen und pragmatischen Überblick
    über die enthaltenen Bausteine sowie deren Schnittstellen.

  - als Liste von Blackbox-Beschreibungen der Bausteine, gemäß dem
    Blackbox-Template (siehe unten). Diese Liste können Sie, je nach
    Werkzeug, etwa in Form von Unterkapiteln (Text), Unter-Seiten (Wiki)
    oder geschachtelten Elementen (Modellierungswerkzeug) darstellen.

- (optional:) wichtige Schnittstellen, die nicht bereits im
  Blackbox-Template eines der Bausteine erläutert werden, aber für das
  Verständnis der Whitebox von zentraler Bedeutung sind. Aufgrund der
  vielfältigen Möglichkeiten oder Ausprägungen von Schnittstellen geben
  wir hierzu kein weiteres Template vor. Im schlimmsten Fall müssen Sie
  Syntax, Semantik, Protokolle, Fehlerverhalten, Restriktionen,
  Versionen, Qualitätseigenschaften, notwendige Kompatibilitäten und
  vieles mehr spezifizieren oder beschreiben. Im besten Fall kommen Sie
  mit Beispielen oder einfachen Signaturen zurecht.
::::

***\<Übersichtsdiagramm\>***

Begründung

:   *\<Erläuternder Text\>*

Enthaltene Bausteine

:   *\<Beschreibung der enthaltenen Bausteine (Blackboxen)\>*

Wichtige Schnittstellen

:   *\<Beschreibung wichtiger Schnittstellen\>*

:::: sidebar
::: title
:::

Hier folgen jetzt Erläuterungen zu Blackboxen der Ebene 1.

Falls Sie die tabellarische Beschreibung wählen, so werden Blackboxen
darin nur mit Name und Verantwortung nach folgendem Muster beschrieben:

+----------------------+-----------------------------------------------+
| **Name**             | **Verantwortung**                             |
+======================+===============================================+
| *\<Blackbox 1\>*     |  *\<Text\>*                                   |
+----------------------+-----------------------------------------------+
| *\<Blackbox 2\>*     |  *\<Text\>*                                   |
+----------------------+-----------------------------------------------+

Falls Sie die ausführliche Liste von Blackbox-Beschreibungen wählen,
beschreiben Sie jede wichtige Blackbox in einem eigenen
Blackbox-Template. Dessen Überschrift ist jeweils der Namen dieser
Blackbox.
::::

### \<Name Blackbox 1\> {#_name_blackbox_1}

:::: sidebar
::: title
:::

Beschreiben Sie die \<Blackbox 1\> anhand des folgenden
Blackbox-Templates:

- Zweck/Verantwortung

- Schnittstelle(n), sofern diese nicht als eigenständige Beschreibungen
  herausgezogen sind. Hierzu gehören eventuell auch Qualitäts- und
  Leistungsmerkmale dieser Schnittstelle.

- (Optional) Qualitäts-/Leistungsmerkmale der Blackbox, beispielsweise
  Verfügbarkeit, Laufzeitverhalten o. Ä.

- (Optional) Ablageort/Datei(en)

- (Optional) Erfüllte Anforderungen, falls Sie Traceability zu
  Anforderungen benötigen.

- (Optional) Offene Punkte/Probleme/Risiken
::::

*\<Zweck/Verantwortung\>*

*\<Schnittstelle(n)\>*

*\<(Optional) Qualitäts-/Leistungsmerkmale\>*

*\<(Optional) Ablageort/Datei(en)\>*

*\<(Optional) Erfüllte Anforderungen\>*

*\<(optional) Offene Punkte/Probleme/Risiken\>*

### \<Name Blackbox 2\> {#_name_blackbox_2}

*\<Blackbox-Template\>*

### \<Name Blackbox n\> {#_name_blackbox_n}

*\<Blackbox-Template\>*

### \<Name Schnittstelle 1\> {#_name_schnittstelle_1}

...​

### \<Name Schnittstelle m\> {#_name_schnittstelle_m}

## Ebene 2 {#_ebene_2}

:::: sidebar
::: title
:::

Beschreiben Sie den inneren Aufbau (einiger) Bausteine aus Ebene 1 als
Whitebox.

Welche Bausteine Ihres Systems Sie hier beschreiben, müssen Sie selbst
entscheiden. Bitte stellen Sie dabei Relevanz vor Vollständigkeit.
Skizzieren Sie wichtige, überraschende, riskante, komplexe oder
besonders volatile Bausteine. Normale, einfache oder standardisierte
Teile sollten Sie weglassen.
::::

### Whitebox *\<Baustein 1\>* {#_whitebox_baustein_1}

:::: sidebar
::: title
:::

...​zeigt das Innenleben von *Baustein 1*.
::::

*\<Whitebox-Template\>*

### Whitebox *\<Baustein 2\>* {#_whitebox_baustein_2}

*\<Whitebox-Template\>*

...​

### Whitebox *\<Baustein m\>* {#_whitebox_baustein_m}

*\<Whitebox-Template\>*

## Ebene 3 {#_ebene_3}

:::: sidebar
::: title
:::

Beschreiben Sie den inneren Aufbau (einiger) Bausteine aus Ebene 2 als
Whitebox.

Bei tieferen Gliederungen der Architektur kopieren Sie diesen Teil von
arc42 für die weiteren Ebenen.
::::

### Whitebox \<\_Baustein x.1\_\> {#_whitebox_baustein_x_1}

:::: sidebar
::: title
:::

...​zeigt das Innenleben von *Baustein x.1*.
::::

*\<Whitebox-Template\>*

### Whitebox \<\_Baustein x.2\_\> {#_whitebox_baustein_x_2}

*\<Whitebox-Template\>*

### Whitebox \<\_Baustein y.1\_\> {#_whitebox_baustein_y_1}

*\<Whitebox-Template\>*

# Laufzeitsicht {#section-runtime-view}

:::::::::::: sidebar
::: title
:::

:::: formalpara
::: title
Inhalt
:::

Diese Sicht erklärt konkrete Abläufe und Beziehungen zwischen Bausteinen
in Form von Szenarien aus den folgenden Bereichen:
::::

- Wichtige Abläufe oder *Features*: Wie führen die Bausteine der
  Architektur die wichtigsten Abläufe durch?

- Interaktionen an kritischen externen Schnittstellen: Wie arbeiten
  Bausteine mit Nutzern und Nachbarsystemen zusammen?

- Betrieb und Administration: Inbetriebnahme, Start, Stop.

- Fehler- und Ausnahmeszenarien

Anmerkung: Das Kriterium für die Auswahl der möglichen Szenarien (d.h.
Abläufe) des Systems ist deren Architekturrelevanz. Es geht nicht darum,
möglichst viele Abläufe darzustellen, sondern eine angemessene Auswahl
zu dokumentieren.

:::: formalpara
::: title
Motivation
:::

Sie sollten verstehen, wie (Instanzen von) Bausteine(n) Ihres Systems
ihre jeweiligen Aufgaben erfüllen und zur Laufzeit miteinander
kommunizieren.
::::

Nutzen Sie diese Szenarien in der Dokumentation hauptsächlich für eine
verständlichere Kommunikation mit denjenigen Stakeholdern, die die
statischen Modelle (z.B. Bausteinsicht, Verteilungssicht) weniger
verständlich finden.

:::: formalpara
::: title
Form
:::

Für die Beschreibung von Szenarien gibt es zahlreiche
Ausdrucksmöglichkeiten. Nutzen Sie beispielsweise:
::::

- Nummerierte Schrittfolgen oder Aufzählungen in Umgangssprache

- Aktivitäts- oder Flussdiagramme

- Sequenzdiagramme

- BPMN (Geschäftsprozessmodell und -notation) oder EPKs
  (Ereignis-Prozessketten)

- Zustandsautomaten

- ...​

:::: formalpara
::: title
Weiterführende Informationen
:::

Siehe [Laufzeitsicht](https://docs.arc42.org/section-6/) in der
online-Dokumentation (auf Englisch!).
::::
::::::::::::

## *\<Bezeichnung Laufzeitszenario 1\>* {#_bezeichnung_laufzeitszenario_1}

- \<hier Laufzeitdiagramm oder Ablaufbeschreibung einfügen\>

- \<hier Besonderheiten bei dem Zusammenspiel der Bausteine in diesem
  Szenario erläutern\>

## *\<Bezeichnung Laufzeitszenario 2\>* {#_bezeichnung_laufzeitszenario_2}

...​

## *\<Bezeichnung Laufzeitszenario n\>* {#_bezeichnung_laufzeitszenario_n}

...​

# 7 Verteilungssicht 


Die Verteilungssicht beschreibt die Laufzeitumgebung von **0 A.D.** sowie die technischen Knoten, auf denen das System betrieben wird. Im Mittelpunkt stehen sowohl die typische Installation auf einem lokalen Client-Rechner als auch das optionale Mehrspielerszenario, bei dem mehrere Clients über ein Netzwerk miteinander kommunizieren.

0 A.D. ist ein plattformübergreifendes Desktop-Spiel und läuft unter Windows, Linux und macOS. Die Engine nutzt OpenGL zur grafischen Darstellung, SpiderMonkey als JavaScript-Laufzeitumgebung sowie ENet als Netzwerkbibliothek für Multiplayer-Partien.

---

## 7.1 Infrastruktur – Ebene 1 (Knotenübersicht)

Die folgende Verteilungssicht umfasst zwei zentrale Ausführungsknoten:

**Lokaler Client-Rechner**  
  Standard-Client eines Spielers. Hier laufen die 0-A.D.-Spielengine, die JavaScript-Laufzeitumgebung sowie sämtliche Grafik- und Audio-Komponenten. Der Client greift auf das lokale Dateisystem zu, um Spielinhalte wie Karten, Mods, Texturen, Sounds sowie Spielstände und Replays zu laden bzw. zu speichern.

**Remote-Client (Mehrspieler)**  
  Optionaler zweiter Client im Mehrspielerbetrieb. Die Architektur basiert auf einem „Peer-to-Host“-Ansatz: Ein Client fungiert als Host, während weitere Clients sich über ENet mit diesem verbinden. Jeder Client führt eine vollständige Instanz der Spielengine aus.

Die Kommunikation erfolgt über ENet auf Basis von UDP. Zwischen den Clients werden in erster Linie Spielbefehle (z. B. Bewegungs- und Bauaufträge) sowie Synchronisationsnachrichten ausgetauscht, um einen konsistenten Spielzustand sicherzustellen – es werden keine Grafiken, Sounds oder Assets übertragen.

![Verteilungssicht von 0 A.D.](images\Verteilungssicht.drawio.png)
Abbildung 7: Verteilungssicht von 0 A.D.
---

## 7.2 Infrastruktur – Ebene 2 (Ausführungsumgebung des lokalen Clients)

Der lokale Client-Rechner umfasst folgende zentrale technische Bausteine:

**Betriebssystem (Windows / Linux / macOS)**  
  Stellt Basisdienste wie Prozessverwaltung, Dateizugriff, Eingabeverarbeitung (Maus, Tastatur) und Netzwerkkommunikation bereit. 0 A.D. unterstützt alle drei Plattformen offiziell.

**GPU und OpenGL-Treiber**  
  Die gesamte grafische Darstellung erfolgt mittels OpenGL. Die Engine nutzt die GPU und den jeweiligen Treiber, um 3D-Modelle, Texturen und Effekte hardwarebeschleunigt zu rendern. Mindestanforderung ist eine GPU mit OpenGL 2.1 oder höher.

**0 A.D. Spielengine (C++)**  
  Die native Engine bildet das Kernsystem und umfasst u. a.:
  - Simulationsschicht (Einheitenlogik, Ressourcenverwaltung, Spielregeln)  
  - Rendering-Schicht (3D-Darstellung, OpenGL-Anbindung)  
  - KI-Komponenten (z. B. skript-gesteuerte Gegner)  
  - UI-/GUI-System (Menüs, HUD, In-Game-Overlays)

**SpiderMonkey (JavaScript-Engine)**  
  Die in die C++-Engine eingebettete JavaScript-Laufzeit SpiderMonkey führt Spielskripte aus. Dazu zählen Simulationslogik, KI-Verhalten sowie Modding-Skripte. Dadurch ermöglicht 0 A.D. eine hohe Flexibilität und erweiterbare Gameplay-Logik.

**ENet (Netzwerkbibliothek)**  
  Für Multiplayer-Partien nutzt 0 A.D. ENet das eine latenzarme und zuverlässige UDP-basierte Kommunikation bereitstellt. ENet übernimmt Paketverwaltung, Verbindungsmanagement sowie grundlegende Zuverlässigkeitsmechanismen.

**OpenAL (Audio-System)**  
  Über OpenAL werden 3D-Sound und Effekte wiedergegeben. Die Engine nutzt OpenAL, um Audioausgabe plattformübergreifend zu abstrahieren.

**Dateisystem (Mods, Karten, Spielstände)**  
  Über das lokale Dateisystem lädt und speichert die Engine:
  - Karten und Szenarien (XML/JSON-basierte Definitionen)  
  - Mods und zusätzliche Inhalte  
  - Texturen, Modelle und Sounds  
  - Spielstände und Replays  

  Diese modulare Struktur erleichtert Modding und Benutzeranpassungen.

---

## 7.3 Kommunikationsbeziehungen im Mehrspielermodus

Im Mehrspielermodus verbindet sich der Remote-Client über ENet/UDP mit dem Host-Client:

- Der Host verwaltet die Multiplayer-Sitzung und fungiert als „Single Source of Truth“ für den globalen Spielzustand.  
- Clients senden Spielbefehle (z. B. Bewegungs- oder Bauaufträge) als Befehlsnachrichten an den Host.  
- Der Host verarbeitet diese Befehle in der Simulationsschicht und verteilt relevante Synchronisationsnachrichten (z. B. aktualisierte Zustände von Einheiten oder Ressourcen) zurück an alle Clients.  

Durch dieses Verfahren entsteht eine verteilte, deterministische Simulation, bei der alle Clients denselben Spielzustand reproduzieren, solange dieselbe Reihenfolge von Befehlen empfangen und verarbeitet wird.


# 8 Querschnittliche Konzepte 

## 8.1 Domänen- und Simulationsmodell (ECS)

Das Domänen- und Simulationsmodell von **0 A.D.** basiert vollständig auf einem Entity-Component-System (ECS). Dieses Modell trennt Spielobjekte in Entitäten, ihre Zustandsdaten in Komponenten sowie die eigentliche Logik in Systeme. Das ECS ist ein zentrales Querschnittskonzept, da nahezu alle Subsysteme des Spiels (Simulation, KI, GUI, Rendering, Netzwerk, Modding) darauf aufbauen oder damit interagieren.

Das ECS-Modell unterstützt mehrere zentrale Qualitätsziele von 0 A.D.:

- Erweiterbarkeit & Modding-Freundlichkeit: Spielinhalte sind vollständig datengetrieben und lassen sich durch neue Komponenten, Werte oder Skripte flexibel erweitern.  
- Determinismus & Multiplayer-Stabilität: Die Simulation läuft in festen Zeitschritten und liefert bei identischen Befehlen exakt dieselben Ergebnisse auf allen Clients.  
- Wartbarkeit: Klare Trennung zwischen Daten (Komponenten) und Logik (Systeme).  
- Performance: Systeme arbeiten effizient auf großen Mengen ähnlich strukturierter Daten, was insbesondere für RTS-Spiele mit vielen Einheiten entscheidend ist.

---

### Grundstruktur des ECS

#### Entitäten

Eine Entität repräsentiert ein konkretes Spielobjekt, z. B.:

- Einheiten, Gebäude, Tiere  
- Ressourcen (Bäume, Mineralien)  
- Projektile  
- Technologien, Effekte oder Statusobjekte  

Entitäten besitzen nur eine eindeutige ID und keine Logik. Ihr Verhalten ergibt sich ausschließlich aus den zugehörigen Komponenten.

---

#### Komponenten

Komponenten enthalten reine Zustandsdaten, z. B.:

- Position: Koordinaten im Weltkoordinatensystem  
- Health: Lebenspunkte  
- Attack: Angriffswerte und -typen  
- ResourceGatherer: Sammel- und Tragekapazitäten  
- Vision: Sichtweite  
- ProductionQueue: Produktions- und Forschungsslots  

Komponenten sind austauschbar, kombinierbar und datengetrieben.  
Sie werden über XML/JSON-Templates definiert (z. B. für Einheiten oder Gebäude) und können durch Mods überschrieben oder erweitert werden.

---

#### Systeme

Systeme enthalten die vollständige Simulationslogik und arbeiten pro Tick auf allen Entitäten, die bestimmte Komponenten besitzen.

Beispiele für Systeme:

- Bewegungssystem (Position, Geschwindigkeit, Pathfinding)  
- Kampfsystem (Attack, Health)  
- Wirtschaftssystem (ResourceGatherer, Storage)  
- Produktionssystem (ProductionQueue, Technology)  
- Sicht- und LOS-System (Vision)  
- KI-Systeme (strategische Entscheidungen, Mikro-Logik)  

Ein System besitzt keinen eigenen Zustand, sondern verarbeitet ausschließlich die Daten der Komponenten.

---

### Deterministische Simulationsschleife

Die Simulation von 0 A.D. läuft in diskreten, deterministischen Ticks.  
Für jeden Tick gilt:

1. Empfang und Verarbeitung von Befehlen (lokal oder aus dem Netzwerk)  
2. Ausführen aller Systeme in einer fest definierten Reihenfolge 
3. Aktualisieren aller betroffenen Komponenten  
4. Export von Änderungsereignissen an GUI, Rendering und Audio  

Diese feste Ausführungsreihenfolge ist Grundlage für:

- Multiplayer-Lockstep-Synchronisation
- Replays (Wiederholungen per Befehlslog)
- OOS-Erkennung (Out-of-Sync)  

Alle Systeme müssen deterministisch arbeiten, d. h. ohne unkontrollierte Zufallszahlen, ohne zeitabhängige Operationen und ohne nicht reproduzierbares Verhalten.

---

### Interaktion mit anderen Subsystemen

Das ECS beeinflusst mehrere Subsysteme querschnittlich:

- GUI: Fragt Entitätsdaten (z. B. Lebenspunkte, Attribute, Befehlsoptionen) über die Engine-API ab.  
- KI: Nutzt ECS-Komponenten, um Entscheidungen über Angriffe, Expansion oder Wirtschaft zu treffen.  
- Pathfinding: Verwendet Positions- und Obstruktionskomponenten.  
- Rendering: Liest visuelle Komponenten (Modelle, Animationen, Ausrichtung).  
- Multiplayer: Alle Entitäten/Komponenten werden deterministisch synchronisiert.  
- Modding: Neue Einheiten, Technologien oder Mechaniken entstehen durch Kombination von Komponenten und/oder neuen Systemen.

Damit bildet das ECS das Rückgrat der gesamten Spielweltlogik.

---

![ECS-Simulation-Diagramm](images/ECS_diagram.drawio.png)

Abbildung 8.1: Ablaufdiagramm der ECS-Struktur 

## 8.2 Datengetriebenes Design & Modding-Konzept

0 A.D. folgt einem strikt datengetriebenen Architekturprinzip, um hohe Flexibilität, Erweiterbarkeit und Modding-Freundlichkeit sicherzustellen.  
Alle spielrelevanten Inhalte — Einheiten, Gebäude, Technologien, Zivilisationen, Karten, KI-Verhalten und die gesamte Benutzeroberfläche, sind nicht im C++-Engine-Code implementiert, sondern werden vollständig über externe Daten beschrieben.

Dies ermöglicht es Gameplay-Designer:innen und Community-Modder:innen, Inhalte zu verändern oder zu erweitern, ohne Anpassungen an der Engine vorzunehmen.  
Das Konzept ist damit ein zentraler Beitrag zur langfristigen Wartbarkeit und Weiterentwicklung des Spiels.

---

### Trennung von Engine und Spieldaten

Die C++-Engine *Pyrogenesis* stellt ausschließlich die technische Basis bereit, darunter:

- Rendering (OpenGL)
- Audio (OpenAL)
- deterministische ECS-Simulation    
- Lockstep-Netzwerkmodell für Multiplayer
- JavaScript-Laufzeitumgebung (SpiderMonkey)
- Mod- und Daten-Ladesystem (virtuelles Dateisystem)

Die konkreten Spielregeln sind nicht im Engine-Code hinterlegt.  
Stattdessen werden sie vollständig durch externe Daten definiert:

- Lebenspunkte  
- Angriffswerte  
- Baukosten  
- Forschungseffekte  
- Sichtweite  
- Zivilisationsboni  
- Ressourcenraten  

Damit bleibt die Engine generisch, während das Gameplay flexibel über Daten gesteuert werden kann.

---

### Datentypen und Formate

0 A.D. nutzt offene und leicht verständliche Formate zur Definition von Spielinhalten:

- XML: Entity Templates (Einheiten, Gebäude, Ressourcen)
- JSON: Technologien, Zivilisationsdaten, Auren
- JavaScript: KI-Skripte, Trigger, GUI-Logik
- XML + JavaScript: Benutzeroberfläche (Layouts + Logik)
- Grafik- und Audiodateien: Modelle, Texturen, Animationen, Sounds
- PO-Dateien: Internationalisierung

Alle spielrelevanten Eigenschaften werden in diesen Dateien beschrieben und können ohne Engine-Modifikation geändert werden.

---

### Mod-Load-System und Override-Mechanismus

Das Modding-System verwendet ein *layer-based overlay model*, das über ein virtuelles Dateisystem (VFS) umgesetzt wird.

Typische Lade-Reihenfolge:

1. `public.zip` — Basispaket der Spielinhalte  
2. `binaries/data/mods/public/` — Hauptspiel („public“-Mod)  
3. `binaries/data/mods/<modname>/` — Benutzer- und Community-Mods  

Regeln des Override-Systems:

- Mods, die später geladen werden, besitzen höhere Priorität.
- Dateien mit identischem Pfad können vollständig überschrieben werden.
- Neue Inhalte können nicht-destruktiv hinzugefügt werden.
- Die Engine führt alle Datenquellen zu einem konsistenten Gesamtzustand zusammen.

Dies ermöglicht Mods unter anderem:

- neue oder veränderte Einheiten  
- alternative Balance-Werte  
- neue Technologien oder Zivilisationen  
- komplette Total-Conversions  
- Änderungen an der Benutzeroberfläche oder KI  

---
### Architekturelle Auswirkungen

Das datengetriebene Design hat weitreichende Konsequenzen für mehrere Teile der Architektur:

- ECS-Komponenten lesen ihre Konfiguration direkt aus Templates, z. B. Sichtweite, Geschwindigkeit oder Ressourcenraten.

- Gameplay-Logik basiert vollständig auf externen Daten, nicht auf hartkodierten Regeln.

- Multiplayer-Determinismus setzt voraus, dass alle Clients exakt dieselben Datenversionen laden.

- Internationalisierung fügt sich nahtlos in die Datenstruktur ein (PO-Dateien als modulare Inhalte).

- Mod-Kompatibilität ergibt sich aus Prioritäten, klar definierten Ladeschichten und Überlagerungsregeln.

- Sicherheit: JavaScript-Code läuft in einer Sandbox, wodurch Mod-Skripte vom Engine-Kern isoliert bleiben.

Das Konzept ist somit ein zentraler Baustein für die konzeptionelle Integrität, Erweiterbarkeit und interne Qualität der gesamten 
0-A.D. Architektur.

## 8.3 Skripting und Engine-Integration (C++ / JavaScript)

0 A.D. setzt bewusst auf eine hybride Architektur aus C++ und JavaScript.  
Performancekritische Funktionen wie Rendering, Simulationstakt, Pathfinding oder Netzwerklogik sind in C++ implementiert, während JavaScript für flexible, datengetriebene Spiellogik sorgt.  
Dieses Konzept ermöglicht eine klare Trennung zwischen Engine und Gameplay, unterstützt Modding und erlaubt schnelle Anpassungen ohne Eingriffe in den C++-Kern.

0 A.D. integriert die JavaScript-Engine *SpiderMonkey* direkt in die C++-Engine (*Pyrogenesis*).  
JavaScript wird an mehreren Stellen genutzt:

- Simulation Components (ECS): Teile der Spieleinheiten-Logik (z. B. Attack, Heal, UnitAI) sind als JavaScript-Komponenten implementiert.
- KI-Skripte: Gegner-KI (z. B. Petra Bot) ist vollständig in JavaScript realisiert.
- Technologien & Effekte: Tech-Effekte und Auren werden in Skripten verarbeitet.
- Trigger- und Szenariologik: Ereignisse auf Karten und in Kampagnen werden über JS gesteuert.
- GUI-Logik: Benutzeroberflächen verwenden XML für Layouts und JavaScript für Ereignisbehandlung und dynamische Inhalte.

Die Engine stellt hierfür ein kontrolliertes API bereit, über das JavaScript sicher mit der Simulation interagiert.

---

### Integration zwischen C++ und JavaScript
Die Verbindung zwischen beiden Welten erfolgt über eine klar definierte Engine-API:

- Zugriff auf Entitäten und ihre Komponenten
- Erstellen, Ändern und Entfernen von Entities
- Senden von Simulation Commands
- Zugriff auf deterministische Zufallszahlen
- Kommunikation über das interne Messaging-System
- Abfragen von Spielerzuständen, Technologien oder Sichtbereichen

JavaScript läuft dabei in einer *Sandbox*, die sicherstellt, dass Skripte:

- nicht auf das Betriebssystem zugreifen,
- keine Threads starten,
- keine Dateien schreiben,
- und ausschließlich Engine-Funktionen verwenden.

Dieses Sandbox-Modell verhindert Sicherheitsrisiken und ist für Multiplayer-Determinismus unverzichtbar.

---

### Rolle im Simulationsablauf
Jeder Simulationstakt (Tick) läuft nach demselben Muster ab:

1. C++-Engine ruft Systems und Komponenten auf.
2. JavaScript-Komponenten führen ihre Logik aus (z. B. Angriff prüfen, KI-Entscheidungen treffen).
3. Änderungen an Komponenten werden zurück in die Engine synchronisiert.
4. Rendering- und Audio-Subsysteme verarbeiten den neuen Zustand.

Damit ist JavaScript direkt in den Simulationsfluss integriert und steuert einen wesentlichen Teil der Spielmechanik.

**Beispiel: JavaScript in einer Simulation-Komponente**
Ein vereinfachtes Beispiel (offizielle Struktur) aus einer Attack-Komponente:

```javascript
PerformAttack: function(target) {
    if (!this.CanAttack(target))
        return;

    let damage = this.GetAttackStrength();
    Engine.PostMessage(this.entity, { "type": "Attack", "target": target, "damage": damage });
}
```
Das Skript nutzt Engine-Funktionen, bleibt aber vollständig deterministisch.

---

### Architekturelle Auswirkungen

Dieses Konzept hat mehrere querschnittliche Auswirkungen:

- Modding-Unterstützung: neue Mechaniken, Technologien oder Einheitentypen können durch JS-Logik ergänzt werden, ohne die Engine zu verändern.
- Determinismus im Multiplayer: JavaScript muss deterministisch ausgeführt werden; deshalb sind Zufallszahlen und Timing-Funktionen streng kontrolliert.

- Wartbarkeit: Gameplay-Logik kann leichter angepasst werden, da sie außerhalb des C++-Kerns liegt.

- Sicherheit: Durch Sandbox-Ausführung sind externe Mods isoliert und können nicht auf Betriebssystemfunktionen zugreifen.

- Konsistenz zwischen Komponenten: Die Integration beeinflusst Simulation, KI, GUI und Datenhaltung gleichermaßen und ist daher ein zentrales Querschnittskonzept.

## 8.4 Netzwerk- und Determinismuskonzept (Lockstep)

0 A.D. verwendet im Mehrspielermodus ein deterministisches Lockstep-Modell.  
Dabei führen alle teilnehmenden Clients die vollständige Simulation lokal aus, während über das Netzwerk ausschließlich Spielerbefehle ausgetauscht werden.  
Dieses Verfahren reduziert den Bandbreitenbedarf, sorgt für faire und konsistente Spielabläufe und ermöglicht exakte Replays.  
Da die gesamte Simulation auf deterministische Ausführung angewiesen ist, zählt dieses Konzept zu den wichtigsten querschnittlichen Aspekten der Architektur.

Im Multiplayer nutzt 0 A.D. eine *Peer-to-Host-Topologie*, bei der ein Client als Host die Sitzung verwaltet.  
Trotzdem läuft die vollständige Simulation auf *allen* Clients, einschließlich des Hosts.

Das Lockstep-Modell funktioniert wie folgt:

1. Die Simulation ist in feste Ticks (Simulationsschritte) unterteilt.  
2. Jeder Client sendet seine Befehle für Tick *N* an den Host.  
3. Der Host verteilt die vollständige Befehlsliste an alle Spieler.  
4. Alle Clients führen den Tick mit exakt denselben Eingaben aus.

Es werden keine Zustände wie Positionen oder Trefferpunkte übertragen, sondern nur abstrakte Befehle wie „Bewege Einheit“ oder „Beginne Bau“.  
Dadurch bleiben Bandbreite und Netzwerklast minimal.

### Determinismus-Anforderungen
Damit alle Clients nach jedem Tick denselben Spielzustand erreichen, gelten strenge Anforderungen:

- Alle Clients müssen identische Daten, Templates und Mods verwenden.  
- JavaScript-Skripte dürfen keine nicht-deterministischen Funktionen nutzen (z. B. Zeitfunktionen).  
- Zufallszahlen stammen aus einem deterministischen RNG mit gemeinsamem Seed.  
- Die Simulation verwendet diskrete Zeit und ist vom Systemzeitpunkt unabhängig.  
- Kritische Logik vermeidet plattformabhängige Floating-Point-Abweichungen.

Kommt es dennoch zu Abweichungen, erkennt die Engine eine Out-of-Sync (OOS) Situation, die zur Fehleranalyse und Replay-Validierung dient.

### Rolle der Netzwerkebene (ENet)
0 A.D. verwendet ENet, eine zuverlässige UDP-basierte Bibliothek, um Befehle zwischen Host und Clients auszutauschen.  
ENet stellt sicher:

- geordnete und zuverlässige Zustellung,  
- effiziente Paketverwaltung,  
- und stabile Verbindungen mit geringer Latenz.

Die Lockstep-Logik baut auf ENet auf und benötigt lediglich, dass für jeden Tick alle Befehle in korrekter Reihenfolge eintreffen.

### Architekturelle Auswirkungen
Das Lockstep-Modell wirkt sich auf zahlreiche Teile des Systems aus:

- Simulation und ECS müssen deterministisch arbeiten.  
- JavaScript läuft in einer Sandbox und darf nur deterministische Engine-APIs nutzen.  
- Modding beeinflusst Multiplayer-Kompatibilität unmittelbar; unterschiedliche Mods führen zu OOS.  
- Performance hängt von der langsamsten Verbindung bzw. dem langsamsten Client ab.  
- Replay- und OOS-Diagnose basieren vollständig auf dem deterministischen Befehlsstrom.

Damit prägt das Lockstep-Konzept nicht nur das Netzwerkmodul, sondern die gesamte Struktur der Simulation, des Skriptings und der Datenhaltung – und ist daher ein zentraler Bestandteil der Architektur von 0 A.D.

## 8.5 Ressourcen- und Asset-Management (Virtual File System, VFS)

0 A.D. verwendet ein Virtual File System (VFS), um den Zugriff auf alle Spieldaten und Assets zu vereinheitlichen – unabhängig davon, wo sie auf dem Datenträger liegen.  
Da das Spiel stark datengetrieben ist und umfangreiches Modding unterstützt, benötigt die Engine einen konsistenten Mechanismus zum Auffinden, Zusammenführen und Überschreiben von Dateien.  
Das VFS stellt plattformunabhängige Pfade bereit, vereinfacht die Integration von Mods und trägt zu Sicherheit und Determinismus bei.

Das VFS abstrahiert das zugrunde liegende Dateisystem, indem es einen *einheitlichen virtuellen Verzeichnisbaum* zur Verfügung stellt.  
Mehrere physische Quellen werden in diesen Baum eingebunden:

- Kernspieldaten (z. B. `public.zip`),  
- das Basis-Spielmodul,  
- benutzererstellte Mods,  
- benutzerspezifische Datenverzeichnisse.

Existiert derselbe virtuelle Pfad in mehreren Quellen, setzt sich die zuletzt eingehängte Quelle durch.  
Dieses Verhalten bildet die technische Grundlage des in Abschnitt 8.2 beschriebenen Mod-Layers.

Die Engine greift ausschließlich über virtuelle Pfade wie:

- `simulation/templates/...`  
- `art/actors/...`  
- `gui/...`  
- `maps/...`  
- `audio/...`

auf Dateien zu und vermeidet damit betriebssystemspezifische Pfadangaben.

### Ressourcenarten und Nutzung
Über das VFS laden alle Subsysteme ihre benötigten Daten:

- Simulationsdaten: XML-Templates, Technologiescripte, Auren, Einheitenwerte.  
- Skripte: JavaScript für KI, Trigger und GUI-Logik.  
- Karten und Szenarien: Höhenkarten, Texturen, Trigger-Skripte.  
- Grafik-Assets: Texturen, Meshes, Animationen, Partikeleffekte, Actor-Dateien.  
- Audio-Assets: Geräusche, Musik und Umgebungsgeräusche.  
- Lokalisierung: PO-Dateien für Übersetzungen.

Da das VFS eine einheitliche Abstraktion bietet, können diese Ressourcen flexibel organisiert oder überschrieben werden, ohne Änderungen am Engine-Code vorzunehmen.

### Sicherheits- und Integrationsaspekte
Das VFS erzwingt strikte Path-Whitelists.  
Verschiedene Engine-Komponenten – einschließlich JavaScript – dürfen nur auf definierte virtuelle Verzeichnisse zugreifen.  
Dadurch wird verhindert, dass:

- auf Betriebssystempfade zugegriffen wird,  
- Dateien außerhalb erlaubter VFS-Bereiche gelesen werden,  
- Mods potenziell unsichere Dateizugriffe durchführen.

Dieses Modell unterstützt Sandboxing, Determinismus und einen stabilen Multiplayer-Betrieb, da alle Clients dieselbe VFS-Struktur verwenden.

### Architekturelle Auswirkungen
Das VFS wirkt sich auf zahlreiche Bereiche der Architektur aus:

- **Modding**  
  Mods werden als zusätzliche VFS-Mounts eingebunden; Überschreibverhalten ergibt sich automatisch.

- **Datengetriebenes Design**  
  Alle Templates, Technologien und GUI-Dateien werden über virtuelle Pfade geladen.

- **Scripting und Sicherheit**  
  JavaScript erhält nur Zugriff auf freigegebene Verzeichnisse, wodurch Mods sicher ausgeführt werden können.

- **Portabilität**  
  Die gleichen virtuellen Pfade funktionieren auf Windows, Linux und macOS.

- **Performance**  
  Als zentraler Zugriffspunkt unterstützt das VFS Caching, Profiling und effizientes Laden von Assets.

Damit stellt das Virtual File System ein wesentliches Querschnittskonzept dar, das die gesamte Laufzeitumgebung von 0 A.D. prägt und die modfreundliche Architektur des Spiels entscheidend ermöglicht.

## 8.6 Internationalisierung (I18N-Konzept)

0 A.D. wird von einer internationalen Community entwickelt und gespielt.  
Damit das Spiel weltweit zugänglich ist, unterstützt die Engine eine vollständig datengetriebene Internationalisierung.  
Alle sichtbaren Texte von GUI-Elementen über Einheitenbeschreibungen bis hin zu Technologien können ohne Änderungen am C++-Code lokalisiert werden.  

Das I18N-Konzept ist deshalb ein zentrales Querschnittsthema:  
Es betrifft die GUI, die templates, JavaScript-Skripte, das Mod-System und den gesamten Asset-Ladeprozess.

---

### Transifex als Übersetzungsplattform

Die Übersetzungen von 0 A.D. werden von der Community über Transifex gepflegt.  
Transifex dient als zentrale Plattform, auf der Freiwillige Übersetzungen bearbeiten, prüfen und aktualisieren.

### PO-Dateien als Laufzeitformat

Die Engine selbst lädt gettext-basierte `.po`-Dateien, die vom Build-Prozess aus Transifex exportiert werden.  
Die Struktur der Dateien folgt dem klassischen gettext-Modell:

```po
msgid "Stone"
msgstr "Stein"
```
Jede aktive Mod kann eigene PO-Dateien bereitstellen.
Der Virtual File System (VFS) Layer bestimmt dabei, welche Dateien Priorität haben.

---

### Integration in Engine und Spielinhalte

**1. GUI (XML + JavaScript):**

Alle GUI-Elemente werden zur Laufzeit über die Engine-Funktion
Engine.Translate() oder automatisch über Layout-Attribute übersetzt.

Beispiele:
- Menütexte
- Tooltip-Beschreibungen
- Buttons, Labels, HUD-Elemente
- Chat- und Lobby-Texte

**2. Entity Templates:**

Templates enthalten englische Standardtexte, z. B. für:
- Einheitennamen
- Beschreibungen
- Technologien
- Auren / Effekte

Die GUI fordert die Übersetzung über die String-ID an, der Simulationscode bleibt sprachneutral.

**3. JavaScript-Skripte:**

JavaScript-Code kann dynamische Texte übersetzen, z. B.:
```
let text = Engine.Translate("Attack Damage");
```
Dies betrifft:
- dynamische GUI-Elemente
- Technologie- und Statistikfenster
- Meldungen und Ereignisse

---

Die Engine lädt die .po-Dateien zur Laufzeit über den VFS und wendet Übersetzungen beim Rendern der GUI an. Fehlende Übersetzungen fallen automatisch auf Englisch zurück.

---

### Architekturelle Auswirkungen

* Trennung von Logik und Darstellung:
Die Simulation arbeitet ausschließlich mit IDs und englischen Basiswerten;
nur die Darstellungsebene nutzt Übersetzungen.

* Modding-Unterstützung:
Mods können eigene Übersetzungen liefern oder vorhandene überschreiben.
Das PO-System ermöglicht vollständige Lokalisierung von Mod-Content.

* VFS-Integration:
Die Übersetzungsdateien folgen denselben Prioritätsregeln wie alle Assets.
Spätere Mods überschreiben frühere PO-Dateien.

* Wartbarkeit: 
Durch die externe Verwaltung über Transifex bleibt der Entwicklungsprozess
schlank und community-freundlich.

* Konsistenz:
Das gettext-basierte Format garantiert einheitliche Struktur und Werkzeuge
(Merge-Tools, automatisierte Checks, Syntaxvalidierung).

## 8.7 Replay-, OOS- und Synchronisationskonzept

Das deterministische Simulationsmodell von 0 A.D. ermöglicht Multiplayer-Spiele, reproduzierbare Replays und eine systematische Analyse von Synchronisationsfehlern.  
Replay-, OOS- und Synchronisationsmechanismen greifen eng ineinander und betreffen Simulation, Netzwerk, Modding und Debugging gleichermaßen.

---

### Replay-System (deterministischer Befehlsstrom)
0 A.D. speichert Replays als Sequenz von Spielerbefehlen pro Simulations-Tick, nicht als Video. Ein Replay enthält:

- den initialen Spielzustand  
- Kartendaten und Seed  
- Spieloptionen  
- den vollständigen Befehlsstrom aller Spieler  

Beim Abspielen wird die Partie vollständig neu simuliert. Da die Simulation deterministisch ist, entspricht der Ablauf exakt dem ursprünglichen Spiel.

**Architekturelle Auswirkungen:**

- Replays sind plattformübergreifend identisch  
- Dateien bleiben sehr klein  
- Änderungen an Templates, Komponenten oder Skripten können ältere Replays ungültig machen  

---

### OOS-Erkennung (Out-of-Sync Detection)
Ein OOS tritt auf, wenn zwei Clients trotz identischer Befehle unterschiedliche Simulationszustände erzeugen.

Die Engine erkennt OOS durch:

- regelmäßige Berechnung eines State-Hashes  
- Austausch der Hashes über das Netzwerk  
- Vergleich der Hashes zwischen allen Teilnehmern  

Bei einer Abweichung erzeugt die Engine:

- detaillierte State Dumps  
- Replay-Fragmente zum Vergleich  
- Diagnose-Logs zur Fehlersuche  

Dies erleichtert die Analyse nichtdeterministischer Modifikationen oder fehlerhafter Systemkomponenten.

---

### Synchronisation im Lockstep-Modell
Die Grundlage für Multiplayer und Replays ist das bereits in 8.4 beschriebene Lockstep-Modell.  
Für diesen Abschnitt relevant ist insbesondere:

- Es werden ausschließlich Befehle synchronisiert, nie Spielzustände  
- Jeder Client simuliert den Spielzustand lokal  
- Identische Eingaben pro Tick garantieren identische Ergebnisse  

Das identische Befehlsmodell ermöglicht:

- deterministische Replays  
- klar nachvollziehbare Sync-Probleme  
- reproduzierbares Debugging  

---

### Anforderungen an deterministisches Verhalten

#### JavaScript
- Verwendung des engine-eigenen deterministischen RNG  
- keine zeit- oder plattformabhängigen Operationen  
- keine Iterationen über nicht deterministische Datenstrukturen  

#### C++/Engine
- deterministische Abläufe und konsistente Rechenoperationen  
- plattformneutrale Implementierung kritischer Funktionen  
- keine hardwareabhängigen oder undefinierten Prozesse  

#### Modding
Mods müssen deterministisch implementiert sein, da ansonsten:

- Multiplayer-Sitzungen OOS gehen  
- Replays inkonsistent werden  
- die Simulation divergiert  

---

### Debugging-, Logging- und Analysewerkzeuge
Zur Unterstützung von Entwicklern und Moddern stellt die Engine verschiedene Mechanismen bereit:

- OOS Dumps mit vollständigen Simulationsdaten  
- State-Hash-Auswertungen zur Fehlersuche  
- Replay-Verifikationsmodus zur Reproduktion von Bugs  
- Turn-Logs zur Analyse der Befehlsausführung  

Diese Werkzeuge machen das deterministische Modell trotz strenger Randbedingungen gut wartbar.

# Architekturentscheidungen 

Dieser Abschnitt stellt drei zentrale Architekturentscheidungen vor, die die Struktur von 0 A.D. beeinflussen.

---

## 9.1 Lockstep-Modell und deterministische Simulation im Multiplayer

### Zur Fragestellung
Eine zentrale Anforderung von 0 A.D. ist die Unterstützung schneller, fairer und skalierbarer Multiplayer-Modus.  
Ein Echtzeitstrategiespiel erzeugt pro Sekunde tausende Zustandsänderungen, Bewegungen, Angriffe, Ressourcensammlungen, Bauprozesse usw.  
Die Frage lautet daher: **Wie bleiben alle Clients synchron, ohne den Netzwerkverkehr zu überlasten?**

0 A.D. muss sicherstellen, dass auf allen Rechnern exakt dieselbe Spielsituation entsteht.  
Die Architektur muss festlegen, **wie der autoritative Zustand entsteht** und **wie die Simulation auf allen Clients im Gleichschritt abläuft**.

---

### Relevante Einflussfaktoren

#### Randbedingungen
- Simulationstakte: 10–30 Updates pro Sekunde  
- Bis zu 8 Spieler pro Match  
- Begrenzte Bandbreite für internationale Spiele notwendig  
- Peer-to-Peer-Modell bevorzugt (kein Server simuliert das gesamte Spiel)

#### Betroffene Qualitätsmerkmale
- Konsistenz / Korrektheit  
- Effizienz durch minimalen Netzwerkverkehr  
- Fairness gegenüber Spielern mit höherer Latenz  
- Modifizierbarkeit, da deterministische Abläufe reproduzierbar sind  

#### Betroffene Risiken
- Out-of-Sync (OOS) bei deterministischen Abweichungen  
- Langsamster Client bestimmt die Spielgeschwindigkeit  
- Erschwerte Fehlersuche bei verzögerter Befehlsausführung  

#### Annahmen
- Die Simulation kann vollständig deterministisch implementiert werden  
- Alle relevanten Operationen können identisch auf allen Clients ablaufen  
- Spieler tolerieren geringe Eingabeverzögerung (~200–500 ms)

---

### Betrachtete Alternativen

#### **Option (1): Zustandssynchronisation**
Regelmäßiges Übertragen des vollständigen Spielzustandes oder von Diffs.

**(+) Positiv**
- Leichter zu debuggen  
- Determinismus nicht zwingend erforderlich  

**(-) Negativ**
- Sehr hoher Bandbreitenbedarf  
- Wenig skalierbar  
- Anfällig für Paketverlust  
- Modding deutlich schwieriger  

---

#### **Option (2): Lockstep + deterministische Simulation (gewählt)**
Es werden ausschließlich *Spielerbefehle* übertragen.  
Jeder Client führt die Simulation synchron aus.

**(+) Positiv**
- Minimaler Netzwerkverkehr  
- Gleichbleibende Spielzustände auf allen Rechnern  
- Gut geeignet für Peer-to-Peer  
- Unterstützt Mods ohne Anpassung des Netzwerkcodes  

**(-) Negativ**
- Erfordert strikten Determinismus  
- Langsamster Client bestimmt den Takt  
- OOS-Debugging komplex

---

### Entscheidung
0 A.D. verwendet das *Lockstep-Modell mit vollständig deterministischer Simulation*.  
Übertragen werden nur Befehle, niemals Spielzustände.  
Alle Clients führen dieselben Befehle im selben Simulationszug aus.

Dies ermöglicht:
- sehr geringe Netzwerklast,  
- konsistente Spielzustände,  
- faire Multiplayer-Partien,  
- hohe Modifizierbarkeit des Spielsystems.

Trotz möglicher OOS-Risiken überwiegen die Vorteile deutlich.

## 9.2 Einsatz eines Entity-Component-Systems (ECS)

### Zur Fragestellung
0 A.D. muss eine große Vielfalt von Spielelementen abbilden:  
Einheiten, Gebäude, Ressourcenquellen, Tiere, Schiffe, Projektile, Technologien, Auren und mehr.  
Diese Objekte besitzen sehr unterschiedliche Kombinationen von Eigenschaften und Verhalten:

- beweglich oder stationär  
- kampffähig oder passiv  
- sammelt oder produziert Ressourcen  
- blockiert Wege, gewährt Sicht, erhöht Population, usw.

Die zentrale Frage lautet:  
**Wie modelliert die Engine diese Spielobjekte so, dass sie flexibel erweiterbar, performant und gut wartbar bleiben – insbesondere im Hinblick auf Modding?**

Von dieser Entscheidung hängen Simulation, Templates, Skripte und große Teile der Codebasis ab.  
Eine nachträgliche Änderung würde praktisch alle Kernsysteme betreffen.

---

### Relevante Einflussfaktoren

#### Randbedingungen
- Implementierung in C++  
- langfristiger Einsatz als modding-freundliche RTS-Engine  
- kontinuierliche Erweiterung des Spiels (neue Zivilisationen, Einheiten, Mechaniken)  
- Entwicklung durch eine verteilte Open-Source-Community

#### Betroffene Qualitätsmerkmale 
- Erweiterbarkeit / Modding-Freundlichkeit  
- Wartbarkeit und Verständlichkeit der Codebasis  
- Performance bei vielen gleichzeitig aktiven Objekten  
- Wiederverwendbarkeit von Logikbausteinen

#### Betroffene Risiken
- zu starre Modellierung erschwert neue Features oder Mods  
- zu komplexes Modell schreckt Beitragende ab  
- Performanceprobleme bei großen Schlachten

#### Annahmen
- Spielmechaniken werden sich über die Zeit ändern und erweitert werden  
- die Engine soll auch für Total-Conversions und umfangreiche Mods geeignet sein  
- eine flexible Datenstruktur rechtfertigt etwas höhere Komplexität im Code

---

### Betrachtete Alternativen

#### Option (1): Klassische objektorientierte Vererbung
Spielelemente werden in einer Klassenhierarchie modelliert, z. B.:

- `Entity` → `Unit` → `Soldier` → `Archer` → `EliteArcher`  
- `Entity` → `Building` → `DefensiveBuilding` → `Tower`

**(+) Positiv**
- auf den ersten Blick leicht verständlich  
- Verhalten kann über Methoden und Vererbung überschrieben werden  

**(-) Negativ**
- starre Hierarchien, schlecht geeignet für Mischformen (z. B. bewegliches Gebäude, Händler mit Aura)  
- zunehmende Tiefe und Breite der Hierarchie erschweren Änderungen  
- schwerer, Logik wiederzuverwenden, ohne Mehrfachvererbung oder Sonderfälle  
- Anpassungen für neue Mechaniken erfordern oft Eingriffe an vielen Stellen im Code

---

#### Option (2): Entity-Component-System (ECS) (gewählt)
Jedes Spielobjekt ist eine *Entity* (ID).  
Eigenschaften und Fähigkeiten werden als *Components* modelliert (z. B. Health, Position, Attack, ResourceGatherer).  
*Systems* verarbeiten alle Entitäten, die eine bestimmte Kombination von Komponenten besitzen.

**(+) Positiv**
- hohe Flexibilität durch Komposition statt Vererbung  
- neue Mechaniken können oft durch zusätzliche Komponenten und Daten eingeführt werden  
- datengetriebene Definition von Einheiten und Gebäuden (→ Templates)  
- performant bei vielen Objekten, da Systeme über homogene Komponentenlisten iterieren  
- gut geeignet für Modding: Verhalten ist über Komponenten / Skripte erweiterbar

**(-) Negativ**
- höhere Einstiegshürde für neue Entwickler  
- Debugging teilweise schwieriger (Verhalten verteilt auf mehrere Systeme)  
- mehr indirekte Zugriffe und Abstraktionsebenen

---

### Entscheidung
0 A.D. verwendet ein *Entity-Component-System* als zentrales Domänenmodell für die Simulation.

Die Entscheidung fiel zugunsten von ECS, weil:

- Komposition statt Vererbung die Kombination von Fähigkeiten vereinfacht  
- Spielinhalte datengetrieben beschrieben und leichter modifiziert werden können  
- das System auch bei vielen Einheiten skalierbar bleibt  
- sich neue Mechaniken häufig ohne Änderungen am Kern der Engine ergänzen lassen

Die erhöhte Komplexität in der Implementierung und im Debugging wird bewusst in Kauf genommen,  
da sie durch mehr Flexibilität, bessere Wiederverwendbarkeit und langfristige Erweiterbarkeit aufgewogen wird.

## 9.3 Datengetriebenes Gameplay mit Templates und JavaScript

### Zur Fragestellung
Ein zentrales Ziel von 0 A.D. ist eine hohe Modifizierbarkeit:  
Neue Einheiten, Gebäude, Technologien oder sogar komplette Spielmechaniken sollen  
*ohne die Engine neu zu kompiliere* erstellt oder verändert werden können.

Daraus ergibt sich die grundlegende Architekturfrage:  
**Werden Spielregeln und Einheitenlogik direkt im C++-Code implementiert,  
oder werden sie in externen Daten- und Skriptdateien definiert?**

Diese Entscheidung beeinflusst nahezu jeden Aspekt des Spiels:  
Balancing, KI, Technologien, Zivilisationsunterschiede, GUI und die Erweiterbarkeit durch Mods.

---

### Relevante Einflussfaktoren

#### Randbedingungen
- offene, community-getriebene Entwicklung  
- zahlreiche Mods und Total-Conversions als Ziel  
- Engine soll möglichst generisch und wiederverwendbar bleiben  
- Trennung von Kernel (C++) und Content (Daten) erwünscht  

#### Maßgeblich betroffene Qualitätsmerkmale
- **Änderbarkeit** (neue Inhalte ohne Engine-Build)  
- **Modding-Unterstützung**  
- **Wartbarkeit** durch klare Trennung von Engine und Spieldaten  
- **Performance** bei großer Anzahl an Einheiten  
- **Stabilität** der Kernsysteme

#### Betroffene Risiken
- zu viel Logik in Skripten kann Performance beeinträchtigen  
- zu viel Logik im C++-Kern erschwert Erweiterbarkeit  
- inkonsistente Datenstrukturen können zu OOS-Fehlern führen  

#### Annahmen
- viele Spielmechaniken lassen sich als Daten ausdrücken (Kosten, Schaden, Reichweite …)  
- komplexere Mechaniken lassen sich in JavaScript erweitern  
- eine hybride Lösung bietet die beste Balance zwischen Performance und Flexibilität

---

### Betrachtete Alternativen

#### Option (1): Gameplay im C++-Code fest verankert
Spielmechaniken sind direkt im Engine-Code implementiert.

**(+) Positiv**
- hohe Performance  
- einfacher zu debuggen  
- deterministisch und stabil  

**(-) Negativ**
- kein direkter Zugriff für Modder  
- jede Regeländerung erfordert Kompilierung  
- schwer, neue Mechaniken hinzuzufügen  
- kaum wiederverwendbar in anderen Projekten

---

#### Option (2): Vollständig skriptbasiertes Gameplay
Sämtliche Mechaniken in einer Skriptsprache (z. B. JavaScript oder Lua).

**(+) Positiv**
- maximale Flexibilität  
- sehr modder-freundlich  

**(-) Negativ**
- Performanceverlust bei großen Schlachten  
- Risiko nichtdeterministischer Abläufe  
- Debugging wird komplexer

---

#### Option (3): Hybrides, datengetriebenes Modell (gewählt)
Spielwerte und Struktur werden in **XML-Templates und JSON-Dateien** definiert.  
Komplexes Verhalten wird **zusätzlich in JavaScript** beschrieben,  
während die Engine **generische C++-Systeme** bereitstellt.

**(+) Positiv**
- hohe Flexibilität ohne Performance vollständig zu opfern  
- keine Engine-Änderung nötig für neue Einheiten/Zivilisationen  
- ideal für Mods und Total-Conversions  
- Engine bleibt generisch und robust  

**(-) Negativ**
- erfordert konsistente Datenstrukturen  
- Mischung aus Daten, JS und C++ kann Einstiegshürde erhöhen

---

### Entscheidung
0 A.D. verwendet ein **hybrides, datengetriebenes Gameplay-Modell**:  
Einheiten, Gebäude und Technologien werden über Templates und JSON-Daten definiert.  
Erweiterbares Verhalten wird über JavaScript implementiert,  
während der C++-Kern generische Systeme für Simulation, Bewegung, Kampf, Ressourcen usw. bereitstellt.

Diese Architektur verbindet die Vorteile hoher Performance mit der Flexibilität,  
umfangreiche Mods und neue Mechaniken ohne Änderung des Engine-Codes zu erstellen.


# Qualitätsanforderungen {#section-quality-scenarios}

:::::::::: sidebar
::: title
:::

:::: formalpara
::: title
Inhalt
:::

Dieser Abschnitt enthält alle relevanten Qualitätsanforderungen.
::::

Die wichtigsten davon haben Sie bereits in Abschnitt 1.2
(Qualitätsziele) hervorgehoben, daher soll hier nur auf sie verwiesen
werden. In diesem Abschnitt 10 sollten Sie auch Qualitätsanforderungen
mit geringerer Bedeutung erfassen, deren Nichterfüllung keine großen
Risiken birgt (die aber *nice-to-have* sein könnten).

:::: formalpara
::: title
Motivation
:::

Weil Qualitätsanforderungen die Architekturentscheidungen oft maßgeblich
beeinflussen, sollten Sie die für Ihre Stakeholder relevanten
Qualitätsanforderungen kennen, möglichst konkret und operationalisiert.
::::

<div>

::: title
Weiterführende Informationen
:::

- Siehe [Qualitätsanforderungen](https://docs.arc42.org/section-10/) in
  der online-Dokumentation (auf Englisch!).

- Siehe auch das ausführliche [Q42 Qualitätsmodell auf
  https://quality.arc42.org](https://quality.arc42.org).

</div>
::::::::::

## Übersicht der Qualitätsanforderungen {#_übersicht_der_qualitätsanforderungen}

:::::::::: sidebar
::: title
:::

:::: formalpara
::: title
Inhalt
:::

Eine Übersicht oder Zusammenfassung der Qualitätsanforderungen.
::::

:::: formalpara
::: title
Motivation
:::

Oft stößt man auf Dutzende (oder sogar Hunderte) von detaillierten
Qualitätsanforderungen für ein System. In diesem Abschnitt sollten Sie
versuchen, sie zusammenzufassen, z. B. durch die Beschreibung von
Kategorien oder Themen (wie z.B. von [ISO
25010:2023](https://www.iso.org/obp/ui/#iso:std:iso-iec:25010:ed-2:v1:en)
oder [Q42](https://quality.arc42.org) vorgeschlagen).
::::

Wenn diese Kurzbeschreibungen oder Zusammenfassungen bereits präzise,
spezifisch und messbar sind, können Sie Abschnitt 10.2 auslassen.

:::: formalpara
::: title
Form
:::

Verwenden Sie eine einfache Tabelle, in der jede Zeile eine Kategorie
oder ein Thema und eine kurze Beschreibung der Qualitätsanforderung
enthält. Alternativ können Sie auch eine Mindmap verwenden, um diese
Qualitätsanforderungen zu strukturieren. In der Literatur (insb.
\[Bass+21\]) ist die Idee eines *Quality Attribute Utility Tree* (auf
Deutsch manchmal kurz als *Qualitätsbaum* bezeichnet) beschrieben
worden, der den Oberbegriff „Qualität" als Wurzel hat und eine
baumartige Verfeinerung des Begriffs „Qualität" verwendet.
::::
::::::::::

## Qualitätsszenarien {#_qualitätsszenarien}

:::::::::::: sidebar
::: title
:::

:::: formalpara
::: title
Inhalt
:::

Qualitätsszenarien konkretisieren Qualitätsanforderungen und ermöglichen
es zu entscheiden, ob sie erfüllt sind (im Sinne von
Akzeptanzkriterien). Stellen Sie sicher, dass Ihre Szenarien spezifisch
und messbar sind.
::::

Zwei Arten von Szenarien finden wir besonders nützlich:

- Nutzungsszenarien (auch bekannt als Anwendungs- oder
  Anwendungsfallszenarien) beschreiben, wie das System zur Laufzeit auf
  einen bestimmten Auslöser reagieren soll. Hierunter fallen auch
  Szenarien zur Beschreibung von Effizienz oder Performance. Beispiel:
  Das System beantwortet eine Benutzeranfrage innerhalb einer Sekunde.

- Änderungsszenarien\_ beschreiben die gewünschte Wirkung einer Änderung
  oder Erweiterung des Systems oder seiner unmittelbaren Umgebung.
  Beispiel: Zusätzliche Funktionalität wird implementiert oder
  Anforderungen an ein Qualitätsmerkmal ändern sich, und der Aufwand
  oder die Dauer der Änderung wird gemessen.

:::: formalpara
::: title
Form
:::

Typische Informationen für detaillierte Szenarien sind die folgenden:
::::

In Kurzform (bevorzugt im Q42-Modell):

- K**ontext/Hintergrund**: Um welche Art von System oder Komponente
  handelt es sich, wie sieht die Umgebung oder Situation aus?

- **Quelle/Stimulus**: Wer oder was initiiert oder löst ein Verhalten,
  eine Reaktion oder eine Aktion aus.

- **Metrik/Akzeptanzkriterien**: Eine Reaktion einschließlich einer
  *Maßnahme* oder *Metrik*

Die Langform von Szenarien (die von der SEI und \[Bass+21\] bevorzugt
wird) ist detaillierter und enthält die folgenden Informationen:

- **Szenario-ID**: Ein eindeutiger Bezeichner für das Szenario.

- **Szenario-Name**: Ein kurzer, beschreibender Name für das Szenario.

- **Quelle**: Die Entität (Benutzer, System oder Ereignis), die das
  Szenario auslöst.

- **Stimulus**: Das auslösende Ereignis oder die Bedingung, auf die das
  System reagieren muss.

- **Umgebung**: Der betriebliche Kontext oder die Bedingungen, unter
  denen das System den Stimulus erlebt.

- **Artefakt**: Die Bausteine oder anderen Elemente des Systems, die von
  dem Stimulus betroffen sind.

- **Reaktion**: Das Ergebnis oder Verhalten, das das System als Reaktion
  auf den Stimulus zeigt.

- **Antwortmaß**: Das Kriterium oder die Metrik, nach der die Antwort
  des Systems bewertet wird.

:::: formalpara
::: title
Beispiele
:::

Ausführliche Beispiele für Qualitätsanforderungen finden Sie auf [der
Website zum Qualitätsmodell Q42](https://quality.arc42.org).
::::

<div>

::: title
Weitere Informationen
:::

- Len Bass, Paul Clements, Rick Kazman: „Software Architecture in
  Practice", 4. Auflage, Addison-Wesley, 2021.

</div>
::::::::::::

# Risiken und technische Schulden {#section-technical-risks}

:::::::::::: sidebar
::: title
:::

:::: formalpara
::: title
Inhalt
:::

Eine nach Prioritäten geordnete Liste der erkannten Architekturrisiken
und/oder technischen Schulden.
::::

<div>

::: title
Motivation
:::

> Risikomanagement ist Projektmanagement für Erwachsene.
>
> ---  Tim Lister Atlantic Systems Guild

</div>

Unter diesem Motto sollten Sie Architekturrisiken und/oder technische
Schulden gezielt ermitteln, bewerten und Ihren Management-Stakeholdern
(z.B. Projektleitung, Product-Owner) transparent machen.

:::: formalpara
::: title
Form
:::

Liste oder Tabelle von Risiken und/oder technischen Schulden, eventuell
mit vorgeschlagenen Maßnahmen zur Risikovermeidung, Risikominimierung
oder dem Abbau der technischen Schulden.
::::

:::: formalpara
::: title
Weiterführende Informationen
:::

Siehe [Risiken und technische
Schulden](https://docs.arc42.org/section-11/) in der
online-Dokumentation (auf Englisch!).
::::
::::::::::::

# Glossar {#section-glossary}

:::::::::::: sidebar
::: title
:::

:::: formalpara
::: title
Inhalt
:::

Die wesentlichen fachlichen und technischen Begriffe, die Stakeholder im
Zusammenhang mit dem System verwenden.
::::

Nutzen Sie das Glossar ebenfalls als Übersetzungsreferenz, falls Sie in
mehrsprachigen Teams arbeiten.

:::: formalpara
::: title
Motivation
:::

Sie sollten relevante Begriffe klar definieren, so dass alle Beteiligten
::::

- diese Begriffe identisch verstehen, und

- vermeiden, mehrere Begriffe für die gleiche Sache zu haben.

:::: formalpara
::: title
Form
:::

Zweispaltige Tabelle mit \<Begriff\> und \<Definition\>.
::::

Eventuell weitere Spalten mit Übersetzungen, falls notwendig.

:::: formalpara
::: title
Weiterführende Informationen
:::

Siehe [Glossar](https://docs.arc42.org/section-12/) in der
online-Dokumentation (auf Englisch!).
::::
::::::::::::

+----------------------+-----------------------------------------------+
| Begriff              | Definition                                    |
+======================+===============================================+
| *\<Begriff-1\>*      | *\<Definition-1\>*                            |
+----------------------+-----------------------------------------------+
| *\<Begriff-2*        | *\<Definition-2\>*                            |
+----------------------+-----------------------------------------------+
